from dataclasses import dataclass
from typing import List
from pathlib import Path

# from mtkcpu.units.memory_interface import MMIOPeriphConfig, MMIOAddressSpace

# MMIO devices derive that class.
class BspGeneratable:
    def get_periph_config(self) -> 'MMIOPeriphConfig':
        raise NotImplementedError("ERROR: To generate code for MMIO device you need to overload get_periph_config function!")


@dataclass(frozen=True)
class MemMapCodeGen:
    from mtkcpu.global_config import Config
    gen_dir = Config.bsp_dir
    periph_addr_basename = "periph_baseaddr"
    base_h_fpath = (gen_dir / periph_addr_basename).with_suffix(".h")
    autogenerated_str = "// Code automatically generated, do not modify!\n"
    log = print

    @staticmethod
    def get_cc_path(addr_scheme : 'MMIOAddressSpace') -> Path:
        return Path(__class__.gen_dir / f"{addr_scheme.basename}.cc")

    @staticmethod
    def get_h_path(addr_scheme : 'MMIOAddressSpace') -> Path:
        return Path(__class__.gen_dir / f"{addr_scheme.basename}.h")

    # TODO fix generation for bits
    @staticmethod
    def __generate_h(cfg : 'MMIOPeriphConfig', addr_scheme : 'MMIOAddressSpace'):
        codelines = []
        codelines.append("// Code automatically generated, do not modify!\n")
        codelines.append(f'#include "{__class__.base_h_fpath.name}"') # defines peripherials base addresses
        for reg in cfg.registers:
            comment = f"/* {reg.description} */"
            line = f"#define {reg.bsp_define_get_name()} ({addr_scheme.bsp_get_base_define_name()} + {hex(reg.addr)})"
            codelines.extend([comment, line, ""])
            for name, offset in reg.bits:
                line = f"#define __{name}_{reg.bsp_define_get_name()}_offset {offset}"
                codelines.extend([line, ""])
        for area in cfg.regions:
            comment = f"/* {area.description} */"
            ptr = f"#define {area.bsp_define_get_name()} {hex(area.start_addr)}"
            size = f"#define {area.bsp_define_get_size_bytes_name()} {hex(area.num_bytes)}"
            codelines.extend([comment, ptr, size, ""])
        __class__.get_h_path(addr_scheme).open("w").writelines([x + '\n' for x in codelines])

    # TODO fix generation for bits
    @staticmethod
    def __generate_cc(cfg : 'MMIOPeriphConfig', addr_scheme : 'MMIOAddressSpace'):
        codelines = []
        codelines.append(__class__.autogenerated_str)
        codelines.append(f'#include "{__class__.get_h_path(addr_scheme).name}"') # it works under assumption that .cc and .h are in same dirs.
        for reg in cfg.registers:
            comment = f"/* {reg.description} */"
            constname, defname = reg.bsp_constexpr_get_name(), reg.bsp_define_get_name()
            line = f"const void* {constname} = (void*) {defname};"
            codelines.extend([comment, line, ""])
            for name, _ in reg.bits:
                name = f"{name}___{reg.bsp_constexpr_get_name()}_offset"
                line = f"constexpr unsigned {name} = (unsigned) __{name};"
                codelines.extend([line, ""])

        for area in cfg.regions:
            defptrname, defsizename = area.bsp_define_get_name(), area.bsp_define_get_size_bytes_name()
            constptrname, constsizename = area.bsp_constexpr_get_name(), area.bsp_constexpr_get_size_bytes_name()
            comment = f"/* {area.description} */"
            ptr_line = f"const void* {constptrname} = (void*) {defptrname};"
            size_line = f"constexpr unsigned {constsizename} = (unsigned) {defsizename};"
            codelines.extend([comment, ptr_line, size_line, ""])
        __class__.get_cc_path(addr_scheme).open("w").writelines([x + '\n' for x in codelines])

    @staticmethod
    def gen_periph_baseaddr(addr_schemes : List['MMIOAddressSpace']):
        path = __class__.base_h_fpath
        lines = []
        lines.append(__class__.autogenerated_str)
        for scheme in addr_schemes:
            lines.append(scheme.bsp_define_base())
        path.open("w").writelines([l + "\n" for l in lines])
        __class__.log(f"ok, {path} file generated!")

    @staticmethod
    def gen_bsp_sources(owners : List['BusSlaveOwnerInterface'], addr_schemes : List['MMIOAddressSpace']):
        log = __class__.log
        log(f"starting bsp code generation inside {__class__.gen_dir} directory..")
        __class__.gen_dir.mkdir(exist_ok=True)
        __class__.gen_periph_baseaddr(addr_schemes)
        bsp_generatables = [(o.get_periph_config(), s) for o, s in zip(owners, addr_schemes) if isinstance(o, BspGeneratable)]
        log(f"found {len(owners)} peripherials, of whom {len(bsp_generatables)} is bsp-generatable..")
        for c, s in bsp_generatables:
            log(f"generating {__class__.get_cc_path(s)}")
            __class__.__generate_cc(c, s)
            log(f"generating {__class__.get_h_path(s)}")
            __class__.__generate_h(c, s)
        log("ok, code generation done!")
